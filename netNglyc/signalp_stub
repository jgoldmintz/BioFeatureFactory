#!/usr/bin/env python3
"""
SignalP stub for NetNGlyc Docker - Communicates with host SignalP 6
This stub writes FASTA to shared volume, signals host to run SignalP 6,
then reads results back
"""

import sys
import os
import time
import json
from pathlib import Path

script_dir = Path(__file__).parent.absolute()

# Try to import utility - fallback to embedded function if not available
try:
    dependencies_dir = script_dir.parents[2] / 'dependencies'
    sys.path.insert(0, str(dependencies_dir))
    from utility import read_fasta as parse_fasta
except:
    # Fallback: Simple FASTA parser embedded in stub
    def parse_fasta(filename):
        """Simple FASTA parser fallback"""
        sequences = {}
        current_name = None
        current_seq = []
        
        try:
            with open(filename, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('>'):
                        if current_name:
                            sequences[current_name] = ''.join(current_seq)
                        current_name = line[1:].split()[0]  # Get first word after >
                        current_seq = []
                    elif line:
                        current_seq.append(line)
                
                # Don't forget the last sequence
                if current_name:
                    sequences[current_name] = ''.join(current_seq)
        except Exception as e:
            print(f"# DEBUG: Error parsing FASTA: {e}", file=sys.stderr)
            return {}
            
        return sequences


def read_signalp6_results():
    """
    Read SignalP 6 results from mounted directory
    The directory is mounted at /signalp_output by the pipeline
    """
    # The SignalP results should be mounted here by Docker
    signalp_file = "/signalp_output/prediction_results.txt"

    # Debug: Check what files exist
    if os.path.exists("/signalp_output"):
        print(f"# DEBUG: /signalp_output exists", file=sys.stderr)
        files = os.listdir("/signalp_output")
        print(f"# DEBUG: Files in /signalp_output: {files}", file=sys.stderr)
    else:
        print(f"# DEBUG: /signalp_output does NOT exist", file=sys.stderr)

    if not os.path.exists(signalp_file):
        print(f"# DEBUG: {signalp_file} not found", file=sys.stderr)
        return None

    print(f"# DEBUG: Reading SignalP results from {signalp_file}", file=sys.stderr)
    results = {}

    try:
        with open(signalp_file, 'r') as f:
            for line in f:
                # Skip comment lines
                if line.startswith('#'):
                    continue

                parts = line.strip().split('\t')
                if len(parts) >= 9:
                    seq_id = parts[0]
                    prediction = parts[1]  # 'SP', 'OTHER', etc.

                    # Column 3 is SP(Sec/SPI) probability
                    try:
                        sp_prob = float(parts[3]) if parts[3] and parts[3] != '' else 0.0
                    except:
                        sp_prob = 0.0

                    # Column 8 (0-indexed) or 9 (1-indexed) is CS Position
                    cs_pos = None
                    if len(parts) > 8 and parts[8] and parts[8].strip():
                        cs_info = parts[8].strip()
                        try:
                            if '-' in cs_info:
                                # Format: "25-26"
                                cs_pos = int(cs_info.split('-')[0])
                            elif cs_info.isdigit():
                                # Format: "25"
                                cs_pos = int(cs_info)
                        except:
                            cs_pos = None

                    # Determine if has signal peptide
                    has_sp = 'Y' if prediction == 'SP' else 'N'

                    # Use appropriate cleavage site position
                    if has_sp == 'Y' and not cs_pos:
                        cs_pos = 25  # Default for signal peptides
                    elif not cs_pos:
                        cs_pos = 22  # Default for no signal peptide

                    results[seq_id] = (has_sp, cs_pos, sp_prob)
                    print(f"# DEBUG: Found {seq_id}: SP={has_sp}, CS={cs_pos}", file=sys.stderr)

        return results
    except Exception as e:
        print(f"# DEBUG: Error reading SignalP results: {e}", file=sys.stderr)
        return None


def analyze_sequence_fallback(seq_name, sequence):
    """
    Fallback: Dynamic analysis when SignalP 6 results not available
    """
    if not sequence or len(sequence) < 10:
        return 'N', 22, 0.1

    seq_len = len(sequence)
    has_signal = 'N'
    cs_pos = 22

    # Basic signal peptide detection
    if sequence[0] == 'M':
        # Analyze hydrophobic content in N-terminal region
        h_region = sequence[5:20] if seq_len > 20 else sequence[5:]
        h_hydrophobic = sum(1 for aa in h_region if aa in 'FLIWVAM') / max(1, len(h_region))

        # Look for cleavage site pattern
        if h_hydrophobic > 0.35:
            # Search for small residues that indicate cleavage site
            for i in range(15, min(30, seq_len)):
                if i >= 3 and i < seq_len:
                    # Check -3, -1 rule
                    if sequence[i - 3] in 'ASGC' and sequence[i - 1] in 'ASGC':
                        has_signal = 'Y'
                        cs_pos = i + 1
                        break

    # Calculate probability based on features
    if has_signal == 'Y':
        prob = 0.7 + (h_hydrophobic * 0.2 if 'h_hydrophobic' in locals() else 0)
    else:
        prob = 0.1

    return has_signal, cs_pos, prob


def format_netnglyc_signalp_line(seq_name, has_signal, cs_pos, probability):
    """
    Format a single line for NetNGlyc's expected signalp.out format
    Returns the formatted line (without newline)
    """
    # Calculate scores based on SignalP probability
    if has_signal == 'Y':
        # Scale scores by probability
        base = max(0.5, probability)
        c_score = min(0.999, base * 0.95)
        y_score = min(0.999, base * 0.92)
        s_score = min(0.999, base * 0.90)
        s_mean = min(0.999, base * 0.80)
        d_score = min(0.999, base * 0.85)
        s_pos = max(1, cs_pos - 5)
    else:
        # No signal peptide - low scores
        c_score = 0.108
        y_score = 0.105
        s_score = 0.128
        s_mean = 0.098
        d_score = 0.102
        s_pos = 3

    # Return 14-column format - NetNGlyc checks column 14 for Y/N
    return (f"{seq_name}\t{c_score:.3f}\t{cs_pos}\t{y_score:.3f}\t{cs_pos}\t"
            f"{s_score:.3f}\t{s_pos}\t{s_mean:.3f}\t{d_score:.3f}\t"
            f"{has_signal}\t0.450\tSignalP-6.0\t?\t{has_signal}")


def output_netnglyc_format(seq_name, has_signal, cs_pos, probability):
    """
    Output in 14-column format that NetNGlyc expects
    NetNGlyc checks column 14 for Y/N based on strace analysis
    """
    # Use the same formatting function for consistency
    line = format_netnglyc_signalp_line(seq_name, has_signal, cs_pos, probability)
    print(line)


def main():
    """
    Main function - parse arguments and process sequences
    """
    # Find FASTA file in arguments
    fasta_file = None

    for arg in sys.argv[1:]:
        # Skip flag arguments
        if arg.startswith('-'):
            continue
        # Check if it's a file
        if os.path.isfile(arg):
            fasta_file = arg
            break

    if not fasta_file:
        # No input file provided
        sys.exit(0)

    # First, try to read SignalP 6 results from mounted directory
    signalp_results = read_signalp6_results()

    # Write results to the location NetNGlyc expects: $GLYCTMP/signalp.out
    glyctmp = os.environ.get('GLYCTMP', '/tmp/netnglyc')
    signalp_out = os.path.join(glyctmp, 'signalp.out')
    
    # Ensure the directory exists
    os.makedirs(glyctmp, exist_ok=True)
    
    with open(signalp_out, 'w') as f:
        if signalp_results:
            # Use real SignalP 6 results
            print(f"# DEBUG: Using SignalP 6 results for {len(signalp_results)} sequences, writing to {signalp_out}", file=sys.stderr)
            for seq_name, (has_sp, cs_pos, sp_prob) in signalp_results.items():
                # Write to signalp.out file in NetNGlyc format
                output_line = format_netnglyc_signalp_line(seq_name, has_sp, cs_pos, sp_prob)
                f.write(output_line + '\n')
                # Also output to stdout for compatibility
                output_netnglyc_format(seq_name, has_sp, cs_pos, sp_prob)
        else:
            # No SignalP results available - use fallback analysis
            print(f"# DEBUG: No SignalP results, using fallback analysis, writing to {signalp_out}", file=sys.stderr)
            sequences = parse_fasta(fasta_file)

            if not sequences:
                # Could not parse FASTA file
                sys.exit(0)

            # Analyze each sequence dynamically
            for seq_name, sequence in sequences.items():
                has_signal, cs_pos, prob = analyze_sequence_fallback(seq_name, sequence)
                # Write to signalp.out file in NetNGlyc format  
                output_line = format_netnglyc_signalp_line(seq_name, has_signal, cs_pos, prob)
                f.write(output_line + '\n')
                # Also output to stdout for compatibility
                output_netnglyc_format(seq_name, has_signal, cs_pos, prob)


if __name__ == "__main__":
    main()